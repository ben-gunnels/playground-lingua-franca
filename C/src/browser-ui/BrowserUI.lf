/**
 * A basic user interface realized in the browser.
 * This program simply counts the number of times the user pushes a button.
 * It reports that number on the web page.
 * 
 * @author Edward A. Lee
 */
target C {
    keepalive: true
}
preamble {=
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <unistd.h>     // Defines read()
    #include <libgen.h>     // Defines dirname()
    
    #if _WIN32 || WIN32
    #define FILE_PATH_SEPARATOR '\\'
    #else
    #define FILE_PATH_SEPARATOR '/'
    #endif
    
    typedef struct browser_ui_t {
        bool running;       // Indicator that listener thread is running.
        int client_socket;  // If non-negative, client socket awaiting response.
        void* req_action;   // The physical action triggered upon request.
    } browser_ui_t;
    
    // Initial web page
    char* initial_page;
    const char html_header[] =  "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/html; charset=UTF-8\r\n\r\n";
    
    void* listener_thread(void* args) {
        browser_ui_t* browser_ui = (browser_ui_t*)args;
        
        int server_socket = socket(AF_INET, SOCK_STREAM, 0);
        if (server_socket < 0) {
            lf_print_error_and_exit("Error creating socket.");
        }

        int one = 1;
        // Allow reusing of local addresses.
        setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(int));

        struct sockaddr_in server_address;
        server_address.sin_family = AF_INET;
        server_address.sin_addr.s_addr = INADDR_ANY;
        server_address.sin_port = htons(8080);

        if (bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) {
            close(server_socket);
            lf_print_error_and_exit("Error binding socket.");
        }
        // Pending queue length of 5.
        listen(server_socket, 5);
        
        lf_print("*** Point your browser to http://localhost:8080");

        while(browser_ui->running) {
            struct sockaddr_in client_address;
            int client_address_length = sizeof(client_address);
    
            browser_ui->client_socket = accept(server_socket, (struct sockaddr *)&client_address, (socklen_t*)&client_address_length);
    
            if (browser_ui->client_socket < 0) {
                lf_print_error_and_exit("Error accepting connection.");
            }

            char buffer[1024] = {0};
            read(browser_ui->client_socket, buffer, 1024);
            printf("Received request: %s\n", buffer);
    
            // The response depends on the path part of the request.
            const char *start_of_path = strchr(buffer, ' ') + 1;
            if (start_of_path != NULL && strncmp("/ ", start_of_path, 2) != 0) {
                const char *end_of_path = strchr(start_of_path, ' ') + 1;
                size_t length = end_of_path - start_of_path;
                char* path = (char*)malloc(length + 1);
                strncpy(path, start_of_path, length);
                path[length] = '\0';
                lf_schedule_value(browser_ui->req_action, 0, path, length + 1);
            } else {
                // Default is to write initial page.
                write(browser_ui->client_socket, html_header, strlen(html_header));
                write(browser_ui->client_socket, initial_page, strlen(initial_page));
                close(browser_ui->client_socket);
                browser_ui->client_socket = -1;
            }
        }
        return NULL;
    }
=}

/**
 * @param initial_file Path to the initial HTML file to serve, relative to the source directory.
 */
reactor ServerUI(initial_file:string = "page.html") {
    output request:char*
    input response:char*
    
    physical action req_action:char*
    
    state browser_ui:browser_ui_t
    
    /**
     * Read a file at path relative to the source .lf file
     * and return dynamically-allocated memory with its contents.
     * The caller is responsible for freeing the pointer returned.
     * @param path File path relative to the source .lf file.
     */
    method read_file(path:{=const char*=}): char* {=
        // Get the full path of the executing binary
        char* bin_path = strdup(__FILE__);
        if (bin_path == NULL) lf_print_error_and_exit("Error getting path to executing binary.");

        // Construct the path to the file to be read
        char* file_path = (char *) malloc(strlen(bin_path) + strlen(path) + 2);
        if (file_path == NULL) lf_print_error_and_exit("Out of memory.");

        sprintf(file_path, "%s%c%s", dirname(bin_path), FILE_PATH_SEPARATOR, path);

        // Open the file for reading
        FILE* file = fopen(file_path, "rb");
        if (file == NULL) lf_print_error_and_exit("Error opening file at path %s.", file_path);

        // Determine the file size
        fseek(file, 0, SEEK_END);
        long file_size = ftell(file);
        fseek(file, 0, SEEK_SET);

        // Allocate memory for the buffer
        char* buffer = (char *) malloc(file_size + 1);
        if (buffer == NULL) lf_print_error_and_exit("Out of memory.");

        // Read the file into the buffer
        fread(buffer, file_size, 1, file);
        buffer[file_size] = '\0';

        free(file_path);
        free(bin_path);
        fclose(file);
        return buffer;
    =}
    
    reaction(startup) -> req_action {=
        // Read the default file to serve.
        initial_page = read_file(self->initial_file);
        
        self->browser_ui.running = true;
        self->browser_ui.client_socket = -1; // No client socket awaiting response.
        self->browser_ui.req_action = req_action;
        lf_thread_t listener;
        lf_thread_create(&listener, &listener_thread, &self->browser_ui);
    =}
    
    reaction(req_action) -> request {=
        lf_set_token(request, req_action->token);
    =}
    
    reaction(response) {=
        if (self->browser_ui.client_socket < 0) {
            lf_print_error("No pending request at the server!");
        }
        char *http_response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n";
        write(self->browser_ui.client_socket, http_response, strlen(http_response));
        write(self->browser_ui.client_socket, response->value, strlen(response->value));
        close(self->browser_ui.client_socket);
        self->browser_ui.client_socket = -1;
    =}
    
    reaction(shutdown) {=
        self->browser_ui.running = false;
        free(initial_page);
    =}
}

main reactor {
    state count:int = 0
    s = new ServerUI(initial_file = "Test.html")
    
    reaction(s.request) -> s.response {=
        char* response;
        asprintf(&response, "You have pushed %d times. Path of GET request: %s", 
            ++self->count,
            s.request->value
        );
        lf_set(s.response, response);
    =}
}