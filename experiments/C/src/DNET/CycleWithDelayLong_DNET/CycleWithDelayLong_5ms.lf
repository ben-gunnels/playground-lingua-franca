target C {
  timeout: 30 sec,
  // logging: debug,
  // DNET: false,
  tracing: true
}

reactor A(Period:time = 20 msec, send:bool = false, ResultFile:string = "..//Results//Dummy.csv") {
  preamble {=
    FILE* fp;
  =}
  timer t(0, Period)

  state count: int = 0

  input in: int

  output out: int

  reaction(startup) {=
    fp = fopen(self->ResultFile, "a");
    if(fp == NULL) {
      lf_print("Couldn't open the file.");
    }
    lf_print("Timer period is %ld.", self->Period);
  =}

  reaction(t) -> out {=
    if (self->send) {
        lf_set(out, 42);
    }
  =}

  reaction(in) {=
    if (lf_time_logical_elapsed() % MSEC(500) == 0) {
      instant_t lag = lf_time_physical() - lf_time_logical();
      if(fp == NULL) {
        lf_print("Couldn't open the file.");
      } else {
        fprintf(fp, "%ld,", lag);
        fprintf(fp, "\n");
      }
    }
  =}

  reaction(shutdown) {=
    fclose(fp);
  =}
}

reactor B {
  input in: int
  output out: int

  reaction(in) -> out {=
    lf_set(out, 42);
  =}
}

reactor C {
  input in: int
  output out: int

  reaction(in) -> out {=
    lf_set(out, 42);
  =}
}

reactor D(Period:time = 100 msec) {
  timer t(0, Period)
  input in: int
  output out: int

  reaction(in, t) -> out {=
    lf_set(out, 42);
  =}

  reaction(shutdown) {=
    //
  =}
}

federated reactor {
  a = new A(Period = 5 msec, send = true, ResultFile = "./CycleWithDelayLong_5ms.csv")
  b = new B()
  c = new C()
  d = new D(Period = 50 msec)

  a.out -> b.in after 100 msec
  b.out -> c.in
  c.out -> d.in
  d.out -> a.in
}
