/**
 * A web socket client enabling a user interface realized in an LF program to interact with a web
 * socket server. This creates a web socket client that connects to a server port (default 8000) for
 * web socket connections. The intended usage is that you create an LF Reactor that utilizes this
 * client to connect to a web socket server defined in `./lib/WebSocketServer.lf`.
 *
 * This uses the <a href="https://libwebsockets.org">libwebsockets</a> (see <a
 * href="https://libwebsockets.org/lws-api-doc-main/html/index.html">API documentation</a> and <a
 * href="https://libwebsockets.org/lws-api-doc-main/html/md_READMEs_README_build.html">installation
 * instructions</a>). To install on MacOS, we recommending using brew:
 * <pre> brew install libwebsockets
 * </pre> This puts the compiled libraries in {@code /usr/local/lib}, and these libraries can be
 * linked to using the {@code -lwebsockets} compile option or the {@code WebSocketCmake.txt} Cmake
 * include file.
 *
 * A key limitation is that this should use the secure sockets API in libwebsockets to get SSL.
 *
 * @param servername The server name, which defaults to "localhost".
 * @param serverport The server port number, which defaults to 8000.
 * @param servicepath The path to the service, which defaults to "/".
 *
 * @author Moez Ben Hajhmida
 */
target C {
  keepalive: true,
  cmake-include: ["WebSocketCmake.txt"]
}

preamble {=
  #ifndef WEBSOCKET_CLT_H
  #define WEBSOCKET_CLT_H
  #include <libwebsockets.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>

  /**
   * A web socket string message together with its web socket instance.
   * This needs a destructor and copy constructor because the message
   * is assumed to be in allocated memory.
   */
   typedef struct web_socket_message_clt_t {
    struct lws* wsi;     // Web socket instance.
    size_t length;
    char* message;
  } web_socket_message_clt_t;


  typedef struct client_status_t {
    void* connected_action;     // Action to notify of changes in connected status.
    void* received_action;    // Action to notify of messages received.
    struct lws_context* context;  // The context.
    bool connected;
  } client_status_t;

    /**
   * Identifier for a web socket instance together with its connected state.
   * No need for a destructor or copy constructor here because the libwebsockets
   * code handles deallocating the wsi when the WS is closed.
   */
   typedef struct web_socket_instance_clt_t {
    struct lws* wsi;     // Web socket instance.
    //bool connected;
  } web_socket_instance_clt_t;

  /** Destructor for an instance of web_socket_message_t. */
  void web_socket_message_destructor(void* message);

  /** Copy constructor for an instance of web_socket_message_t. */
  void* web_socket_message_copy_constructor(void* message);

  #endif //WEBSOCKET_CLT_H
=}

reactor WebSocketClient(
  servername: string = "localhost",
  serverport: int = 8000,
  servicepath: string = "/") {
  output connected: web_socket_instance_clt_t
  output received: web_socket_message_clt_t*

  input in_dynamic: char*
  input in_static: string

  physical action connected_action: web_socket_instance_clt_t
  physical action received_action: web_socket_message_clt_t*

  state status: client_status_t

  // output received: char*
  preamble {=
      struct lws_context_creation_info info;
      struct lws_client_connect_info ccinfo;
      char* to_send;

      static int client_connected = 0;



    static int callback_ws( struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len )
    {
      client_status_t* status = (client_status_t*)lws_context_user(lws_get_context(wsi));

    	switch( reason )
    	{
    		case LWS_CALLBACK_CLIENT_ESTABLISHED:
          client_connected =1;
          lf_print("******  connected to server\n");
    			break;

    		case LWS_CALLBACK_CLIENT_RECEIVE:
          if (len > 0) {
            LF_PRINT_LOG("******  ws client received '%s'\n", in);
            lf_print("******  ws client received '%s'\n", in);

            web_socket_message_clt_t* received = (web_socket_message_clt_t*)malloc(sizeof(web_socket_message_clt_t));
            received->wsi = wsi;

            // To protect against non-null-terminated strings, add a null character beyond the length.
            void* payload = malloc((len + 1) * sizeof(char));
            memcpy(payload, in, len);
            ((char*)payload)[len] = '\0';
            received->length = len;
            received->message = payload;
            //received->binary = true; // Treat all received data as binary.
            // Carry the null terminator in the action payload, just in case.
            lf_schedule_value(status->received_action, 0, received, len + 1);
          }
    			break;

    		case LWS_CALLBACK_CLIENT_WRITEABLE:
    		{
          int to_send_len = strlen(to_send);
    			unsigned char buf[LWS_SEND_BUFFER_PRE_PADDING + to_send_len + LWS_SEND_BUFFER_POST_PADDING];
    			unsigned char *p = &buf[LWS_SEND_BUFFER_PRE_PADDING];
    			size_t n = sprintf( (char *)p, "%s", (char *)to_send );
    			lws_write( wsi, p, n, LWS_WRITE_TEXT );
    			break;
    		}

    		case LWS_CALLBACK_CLIENT_CLOSED:
        {
          break;

        }
    		case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
    			wsi = NULL;
    			break;

    		default:
    			break;
    	}

    	return 0;
    }

    // Thread handling incoming messages.    
    void* websocket_thread(void* args) {
      client_status_t* status = (client_status_t*)args;
      
      while(status->context) {
        // Invoke any pending callbacks.
        // According to the docs, the timeout argument is ignored.
        // Nevertheless, set to 100ms.
        lws_service(status->context, 100);
        
      }
      lws_context_destroy(status->context);
      return NULL;
    };


    enum protocols
    {
      PROTOCOL_EXAMPLE = 0,
      PROTOCOL_COUNT
    };


    static struct lws_protocols protocols[] = {
        {"http", callback_ws, 0, 0},
        {"https", callback_ws, 0, 0},
        {"ws", callback_ws, 0, 0},
        {"wss", callback_ws, 0, 0},
        {NULL, NULL, 0, 0}
    };

    void web_socket_message_destructor(void* message) {
      free(((web_socket_message_clt_t*)message)->message);
      free(message);
      // Do not free the wsi.
    }

    // Argument and return type is web_socket_message_t*.
    void* web_socket_message_copy_constructor(void* message) {
      web_socket_message_clt_t* cast = (web_socket_message_clt_t*)message;
      web_socket_message_clt_t* result = (web_socket_message_clt_t*)malloc(sizeof(web_socket_message_clt_t));
      size_t length = cast->length;
      void* copy = malloc(length * sizeof(char));
      result->message = memcpy(copy, cast->message, length);
      result->wsi = cast->wsi;
      result->length = length;
      return result;
    }
  =}

  reaction(startup) -> connected_action, received_action, connected {=
    // The receiving thread dynamically allocates memory for messages.
    // Set the destructor and copy constructor.
    lf_set_destructor(received_action, web_socket_message_destructor);
    lf_set_copy_constructor(received_action, web_socket_message_copy_constructor);

        memset(&info, 0, sizeof(info));

        info.port = CONTEXT_PORT_NO_LISTEN;
        info.protocols = protocols;
        info.gid = -1;
        info.uid = -1;
        // To get callbacks to be passed a pointer to the status struct:
        info.user = &self->status;

        self->status.context = lws_create_context(&info);
        if (!self->status.context) {
            fprintf(stderr, "Error creating libwebsocket context\n");
            return -1;
        }


    /* Connect if we are not connected to the server. */
    if( !connected->value.wsi )
    		{
        memset(&ccinfo, 0, sizeof(ccinfo));

    		ccinfo.context = self->status.context;
        ccinfo.address = self->servername;
        ccinfo.port = self->serverport;
        ccinfo.path = self->servicepath;
        ccinfo.host = ccinfo.address;
        ccinfo.origin = ccinfo.address;
        ccinfo.protocol = "ws";

        self->status.connected_action = connected_action;
        self->status.received_action = received_action;


        connected->value.wsi = lws_client_connect_via_info(&ccinfo);


        while (!lws_service(self->status.context, 50) && !client_connected) {
    					// Wait for the connection to complete
    					LF_PRINT_LOG("Wait for the connection to complete ...\n");
              lf_sleep(MSEC(10));
    				}
    		}

        lf_thread_t listener;
        lf_thread_create(&listener, &websocket_thread, &self->status);

  =}

  reaction(in_dynamic, in_static) -> connected {=
    if (client_connected) {
      char* message_copy;
      if (in_dynamic->is_present) {
        message_copy = (char*)malloc(strlen(in_dynamic->value));
        strcpy(message_copy, in_dynamic->value);
      } else {
        message_copy = (char*)malloc(strlen(in_static->value));
        strcpy(message_copy, in_static->value);
      }

      to_send = message_copy;


      LF_PRINT_LOG("******> ws client sending: %s", message_copy);

      lws_callback_on_writable(connected->value.wsi );

    } else {
      // Web socket is not connected.
      lf_print_warning("******  Web socket client is not connected. Dropping message to send.");
    }
  =}

  reaction(received_action) -> received {=
    lf_set_token(received, received_action->token);
  =}

  reaction(connected_action) -> connected {=
    lf_set(connected, connected_action->value);
  =}

  reaction(shutdown) {=
    lws_context_destroy(self->status.context);
  =}
}
