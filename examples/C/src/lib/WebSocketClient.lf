target C {
  keepalive: true,
  cmake-include: ["WebSocketCmake.txt"]
}

// import WebSocketServer from "../lib/WebSocketServer.lf"

preamble {=
  #ifndef WEBSOCKET_CLT_H
  #define WEBSOCKET_CLT_H
  #include <libwebsockets.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>

  /**
   * A web socket string message together with its web socket instance.
   * This needs a destructor and copy constructor because the message
   * is assumed to be in allocated memory.
   */
   typedef struct web_socket_message_clt_t {
    struct lws* wsi;     // Web socket instance.
    size_t length;
    char* message;
  } web_socket_message_clt_t;


  typedef struct client_status_t {
    void* connected_action;     // Action to notify of changes in connected status.
    void* received_action;    // Action to notify of messages received.
    struct lws_context* context;  // The context.
    bool connected; 
  } client_status_t;

    /**
   * Identifier for a web socket instance together with its connected state.
   * No need for a destructor or copy constructor here because the libwebsockets
   * code handles deallocating the wsi when the WS is closed.
   */
   typedef struct web_socket_instance_clt_t {
    struct lws* wsi;     // Web socket instance.
    //bool connected;
  } web_socket_instance_clt_t;
  #endif //WEBSOCKET_CLT_H
  
=}

reactor WebSocketClient(servername: string = "localhost", serverport: int = 8000, servicepath: string = "/") {
  output connected: web_socket_instance_clt_t
  //output received: web_socket_message_clt_t*
  input send: char*

  physical action connected_action: web_socket_instance_clt_t
  // physical action received_action: web_socket_message_clt_t*

  state status: client_status_t
  

  input in_dynamic: char*
  input in_static: string
  output received: char*


  
  preamble {=
      struct lws_context_creation_info info;
      struct lws_client_connect_info ccinfo;
      char* to_send;

      static int client_connected = 0;



    static int callback_ws( struct lws *wsi, enum lws_callback_reasons reason, void *user, void *in, size_t len )
    {
      char* message_copy;

    	switch( reason )
    	{
    		case LWS_CALLBACK_CLIENT_ESTABLISHED:
          client_connected =1;
          lf_print("******  connected to server\n");
    			break;

    		case LWS_CALLBACK_CLIENT_RECEIVE:
    			/* Handle incomming messages here. */
          message_copy = (char*)malloc(len);
          strcpy(message_copy, in);
		      lf_print("******  ws client received %ld from server '%s'\n", (long)len, message_copy);
    			break;

    		case LWS_CALLBACK_CLIENT_WRITEABLE:
    		{
          int to_send_len = strlen(to_send);
    			unsigned char buf[LWS_SEND_BUFFER_PRE_PADDING + to_send_len + LWS_SEND_BUFFER_POST_PADDING];
    			unsigned char *p = &buf[LWS_SEND_BUFFER_PRE_PADDING];
    			size_t n = sprintf( (char *)p, "%s", (char *)to_send );
    			lws_write( wsi, p, n, LWS_WRITE_TEXT );
    			break;
    		}

    		case LWS_CALLBACK_CLIENT_CLOSED:
        {
          break;

        }
    		case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
    			wsi = NULL;
    			break;

    		default:
    			break;
    	}

    	return 0;
    }

    enum protocols
    {
      PROTOCOL_EXAMPLE = 0,
      PROTOCOL_COUNT
    };


    static struct lws_protocols protocols[] = {
        {"http", callback_ws, 0, 0},
        {"https", callback_ws, 0, 0},
        {"ws", callback_ws, 0, 0},
        {"wss", callback_ws, 0, 0},
        {NULL, NULL, 0, 0}
    };
  =}

  reaction(startup) -> connected_action, connected {=
    //self->status = false;

    memset(&info, 0, sizeof(info));
    

    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;
    info.gid = -1;
    info.uid = -1;
    // To get callbacks to be passed a pointer to the status struct:
    info.user = &self->status;
  


    self->status.context = lws_create_context(&info);
    if (!self->status.context) {
        fprintf(stderr, "Error creating libwebsocket context\n");
        return -1;
    }

    
    
/* Connect if we are not connected to the server. */
if( !connected->value.wsi )
		{
    memset(&ccinfo, 0, sizeof(ccinfo));

		ccinfo.context = self->status.context;
    ccinfo.address = self->servername;
    ccinfo.port = self->serverport;
    ccinfo.path = self->servicepath;
    ccinfo.host = ccinfo.address;
    ccinfo.origin = ccinfo.address;
    ccinfo.protocol = "ws";

    self->status.connected_action = connected_action;
   

    connected->value.wsi = lws_client_connect_via_info(&ccinfo);
    while (!lws_service(self->status.context, 50) && !client_connected) {
					// Wait for the connection to complete
					LF_PRINT_LOG("Wait for the connection to complete ...\n");
				}
		}
    return 0;
  =}

reaction(in_dynamic, in_static) ->connected{=
  if (client_connected) {
    char* message_copy;
    if (in_dynamic->is_present) {
      message_copy = (char*)malloc(strlen(in_dynamic->value));
      strcpy(message_copy, in_dynamic->value);
    } else {
      message_copy = (char*)malloc(strlen(in_static->value));
      strcpy(message_copy, in_static->value);
    }

    to_send = message_copy;


    LF_PRINT_LOG("******> ws client sending: %s", message_copy);
    
    lws_callback_on_writable(connected->value.wsi ); 
    lws_service( self->status.context, /* timeout_ms = */ 250 );
  } else {
    // Web socket is not connected.
    lf_print_warning("******  Client Web socket is not connected. Dropping message to send.");
  }
=}


   
// lws_callback_on_writable( connected->value.wsi );   
// lws_service( self->status.context, /* timeout_ms = */ 250 );

reaction(shutdown) {=
  lws_context_destroy(self->status.context);
=}

}

