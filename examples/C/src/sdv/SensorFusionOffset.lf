/**
 * Sensor fusion mock up.
 * @author Ravi Akella
 * @author Marten Lohstroh
 */
target C {
  timeout: 1 sec,
  coordination: decentralized  // better performance than centralized
}

preamble {=
  #include "platform.h"
  #include <stdlib.h> // rand, srand
=}

@label("ASIL B")
reactor Sensor(period: time = 100 ms) {
  timer t(0, period)
  output out: int
  state count: int

  reaction(t) -> out {=
    lf_set(out, self->count);
    self->count++;
  =}
}

@label("ASIL D")
reactor Processor(processingTime: time = 10 ms) {
  input[2] inp: int
  output out: int

  reaction(inp) -> out {=
    //interval_t before = lf_time_physical_elapsed();
    lf_sleep(self->processingTime);
    //printf("Physical time elapsed: %lld\n", lf_time_physical_elapsed() - before);
    bool synced = false;
    if (inp[0]->is_present && inp[1]->is_present) {
       synced = true;
       printf("\n---- SYNC'ED ----\n");
    }
    if (inp[0]->is_present) {
        printf(">>> camera frame: %d\n", inp[0]->value);
    }
    if (inp[1]->is_present) {
        printf(">>>> lidar frame: %d\n", inp[1]->value);
    }
    if (synced) {
        printf("-----------------\n\n");
    }
    srand(inp[0]->value);
    int r = rand();
    if (r % 2) {
        lf_set(out, r % 100);
    }
    interval_t logical_elapsed = lf_time_logical_elapsed();
    interval_t diff_us = (lf_time_physical_elapsed() - logical_elapsed) / 1000;
    printf("(processor lagging physical time by %lld us at %lld ms)\n", diff_us, logical_elapsed / 1000000);
  =}
}

@label("ASIL D")
reactor Brakes extends Actuator {
}

@label("QM")
reactor Display extends Actuator {
}

reactor Actuator(name: char* = "actuator", maxLag: time = 150 ms) {
  input inp: int
  state misses: int = 0

  reaction(inp) {=
    interval_t logical_elapsed = lf_time_logical_elapsed();
    interval_t diff_us = (lf_time_physical_elapsed() - logical_elapsed) / 1000;
    printf("(%s lagging physical time by %lld us at %lld ms)\n", self->name, diff_us, logical_elapsed / 1000000);
  =} deadline(maxLag) {=
    self->misses++;
    printf("---- DEADLINE MISS ----\n");
    interval_t logical_elapsed = lf_time_logical_elapsed();
    interval_t diff_us = (lf_time_physical_elapsed() - logical_elapsed) / 1000;
    printf("(%s lagging physical time by %lld us at %lld ms)\n", self->name, diff_us, logical_elapsed / 1000000);
    printf("---- DEADLINE MISS ----\n");
  =}

  reaction(shutdown) {=
    printf("---- Deadline misses at %s: %d\n", self->name, self->misses);
  =}
}

main reactor(processingTime: time = 30 ms) {
  // Note: if period of the sensor is smaller than the processing time,
  // then lag will grow without bound, and all deadlines will be missed!
  // The processor implements a logical delay (effectively a LET) equal
  // to the processing time.
  // The end-to-end physical time delay between sensor and actuator then
  // will be equal to the processingTime plus additional lag incurred
  // by message relay. This additional lag is bounded by the specified
  // deadline.
  video = new Sensor(period = 40 ms)
  lidar = new Sensor(period = 200 ms)  // 5hz

  processor = new Processor(processingTime=processingTime)
  display = new Display(name="display")
  brakes = new Brakes(name="brakes", maxLag = 50 ms)

  video.out, lidar.out -> processor.inp

  processor.out -> display.inp after processingTime
  processor.out -> brakes.inp after processingTime
}
