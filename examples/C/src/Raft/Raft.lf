/**
 * An LF program implementing the Raft protocol
 *
 * @author Shaokai Lin<shaokai@berkeley.edu>
 */
target C {
  coordination: decentralized
}

preamble {=
  #define MSG_HEART       -1
  #define MSG_ACK         -2
  #define MSG_ELECTION    -3
  #define MSG_VOTE        -4
  #define MSG_LEADER      -5

  #define TIMEOUT_MS_LOW  150
  #define TIMEOUT_MS_HIGH 300

  typedef struct msg_t {
      int payload;
      int term;
  } msg_t;
=}

reactor Node(bank_index: int = 0, num_nodes: size_t = 1, heartbeat_period: time = 100 msec) {
  input[num_nodes] in: msg_t
  output[num_nodes] out: msg_t

  state leader: int  // A node who this node believes is the current leader.
  state election_timeout: time
  state term: int = 0

  // The follower schedules a timeout action in case a heartbeat
  // does not arrive. When the heartbeat does arrive, the pending
  // action will be replaced by a new action with a later expiry.
  // The minimum spacing of "forever" ensure that only one
  // election_timeout_reached event can stay on the event queue.
  // This is an implementation of a watchdog.
  //
  // FIXME: Not for this case, but it would be nice to be able to
  // use state variables in action parameters.
  logical action election_timeout_reached(0 sec, forever, "replace")
  logical action start_election

  method random_int_in_range(min: int, max: int): int {=
    srand(lf_time_physical()); // Choose a random seed.
    return rand() % ((max + 1) - min) + min;
  =}

  method create_msg(payload: int): msg_t {=
    return (msg_t){.payload=payload, .term=self->term};
  =}

  // FIXME: Cannot use ports in methods.
  /**
   * method broadcast_message(out : port, payload : int) {= Broadcast a heartbeat message to all
   * nodes. for (int i = 0; i < self->num_nodes; i++) { lf_set(out[i], payload); }
   * =}
   */
  reaction(in) {=
    for (int i = 0; i < in_width; i++) {
        if (in[i]->is_present) {
            lf_print("(%lld, term=%d) Received from reactor %d: {payload=%d, term=%d}", lf_time_logical_elapsed(), self->term, i, in[i]->value.payload, in[i]->value.term);
        }
    }
  =}

  initial mode Follower {
    reaction(startup) -> election_timeout_reached {=
      lf_print("(%lld, term=%d, leader=%d, Follower) Hello", lf_time_logical_elapsed(), self->term, self->leader);
      // Choose a random election timeout between 150~300ms.
      // In practice, this seems way too small.
      self->election_timeout = MSEC(random_int_in_range(TIMEOUT_MS_LOW, TIMEOUT_MS_HIGH));
      lf_print("(%lld, term=%d, leader=%d, Follower) election timeout = %lld", lf_time_logical_elapsed(), self->term, self->leader, self->election_timeout);
      // Schedule the first timeout action.
      lf_schedule(election_timeout_reached, self->election_timeout);
    =}

    reaction(in) -> out, election_timeout_reached {=
      for (int i = 0; i < in_width; i++) {
          if (in[i]->is_present && i != self->bank_index) {
              if (i == self->leader
                  && in[i]->value.payload == MSG_HEART) {
                  lf_print("(%lld, term=%d, leader=%d, Follower) Received MSG_HEART from %d", lf_time_logical_elapsed(), self->term, self->leader, i);
                  // Make sure its term is the same as the leader's term.
                  self->term = in[i]->value.term;
                  // Send back an ack.
                  lf_set(out[i], create_msg(MSG_ACK));
                  lf_print("(%lld, term=%d, leader=%d, Follower) Sent MSG_ACK to %d", lf_time_logical_elapsed(), self->term, self->leader, i);
                  // Renew the pending timeout action's expiry time.
                  lf_schedule(election_timeout_reached, self->election_timeout);
              }
              else if (i != self->leader
                      && in[i]->value.payload == MSG_ELECTION) {
                  lf_print("(%lld, term=%d, leader=%d, Follower) Received MSG_ELECTION from %d", lf_time_logical_elapsed(), self->term, self->leader, i);
                  // Send back a vote.
                  lf_set(out[i], create_msg(MSG_VOTE));
                  lf_print("(%lld, term=%d, leader=%d, Follower) Sent MSG_VOTE to %d", lf_time_logical_elapsed(), self->term, self->leader, i);
                  // Renew the pending timeout action's expiry time.
                  lf_schedule(election_timeout_reached, self->election_timeout);
              }
              else if (i != self->leader
                      && in[i]->value.payload == MSG_LEADER) {
                  lf_print("(%lld, term=%d, leader=%d, Follower) Received MSG_LEADER from %d", lf_time_logical_elapsed(), self->term, self->leader, i);
                  // A new leader has been declared.
                  self->leader = i;
                  // Update its term to the leader's term.
                  self->term = in[i]->value.term;
                  // Send back an ack.
                  lf_set(out[i], create_msg(MSG_ACK));
                  lf_print("(%lld, term=%d, leader=%d, Follower) Sent MSG_ACK to %d", lf_time_logical_elapsed(), self->term, self->leader, i);
                  // Renew the pending timeout action's expiry time.
                  lf_schedule(election_timeout_reached, self->election_timeout);
              }
          }
      }
    =}

    reaction(election_timeout_reached) -> start_election, reset(Candidate) {=
      lf_print("(%lld, Follower) Timeout! Starting an election...", lf_time_logical_elapsed());
      lf_schedule(start_election, 0);
      lf_set_mode(Candidate);
    =}
  }

  mode Leader {
    // The leader periodically sends out a heartbeat message to all
    // follower nodes to maintain authority.
    timer heartbeat(0, heartbeat_period)
    reaction(heartbeat) -> out {=
      // Broadcast a heartbeat message to all nodes.
      for (int i = 0; i < self->num_nodes; i++) {
          lf_set(out[i], create_msg(MSG_HEART));
      }
      lf_print("(%lld, term=%d, leader=%d, Leader) Broadcast MSG_HEART", lf_time_logical_elapsed(), self->term, self->leader);
    =}

    reaction(in) -> out, election_timeout_reached, reset(Follower) {=
      // Receive acks from followers.
      for (int i = 0; i < self->num_nodes; i++) {
          if (in[i]->is_present && i != self->bank_index) {
              if (in[i]->value.payload == MSG_HEART) {
                  // Compare the term id, if they are equal, compare bank_index.
                  if (in[i]->value.term > self->term
                      || (in[i]->value.term == self->term && i > self->bank_index)) {
                      // Another node has declared itself to be the leader.
                      self->leader = i;
                      // Send back an ack.
                      lf_set(out[i], create_msg(MSG_ACK));
                      lf_print("(%lld, term=%d, leader=%d, Leader) Acknowledge %d as the supreme leader", lf_time_logical_elapsed(), self->term, self->leader, i);
                      // Update its term to the leader's term.
                      self->term = in[i]->value.term;
                      // Renew the pending timeout action's expiry time.
                      lf_schedule(election_timeout_reached, self->election_timeout);
                      // Become a follower.
                      lf_set_mode(Follower);
                  }
              }
              else if (in[i]->value.payload == MSG_ACK) {
                  lf_print("(%lld, term=%d, leader=%d, Leader) Received ack from follower node %d", lf_time_logical_elapsed(), self->term, self->leader, i);
              }
          }
      }
    =}
  }

  mode Candidate {
    reset state votes_received: int = 0
    reaction(start_election) -> out, election_timeout_reached {=
      // Reset the vote count to 0.
      // NOTE: This was a real bug, which could be a good test case for model checking.
      self->votes_received = 0;
      // Vote for itself.
      self->votes_received++;
      // Broadcast an election start message.
      for (int i = 0; i < self->num_nodes; i++) {
          lf_set(out[i], create_msg(MSG_ELECTION));
      }
      lf_print("(%lld, term=%d, leader=%d, Candidate) Broadcast MSG_ELECTION", lf_time_logical_elapsed(), self->term, self->leader);
      // Schedule a timeout action to collect votes.
      lf_schedule(election_timeout_reached, self->election_timeout);
    =}

    reaction(in) -> out, election_timeout_reached, reset(Leader), reset(Follower) {=
      // Receive votes from followers.
      for (int i = 0; i < self->num_nodes; i++) {
          if (in[i]->is_present && i != self->bank_index) {
              if (in[i]->value.payload == MSG_VOTE) {
                  lf_print("(%lld, term=%d, leader=%d, Candidate) Received a vote from follower node %d", lf_time_logical_elapsed(), self->term, self->leader, i);
                  self->votes_received++;
                  // Check if a majority of votes is received, if so,
                  // declare to be the leader.
                  if (self->votes_received > self->num_nodes / 2) {
                      // Increment its term id.
                      self->term++;
                      // Broadcast a leader message to all nodes.
                      for (int i = 0; i < self->num_nodes; i++) {
                          lf_set(out[i], create_msg(MSG_LEADER));
                      }
                      // Mark itself as the leader.
                      self->leader = self->bank_index;
                      // Transition to leader mode.
                      lf_set_mode(Leader);
                      lf_print("(%lld, term=%d, leader=%d, Candidate) Votes received: %d / %d. Declaring leader!", lf_time_logical_elapsed(), self->term, self->leader, self->votes_received, self->num_nodes);
                  }
              }
              else if (in[i]->value.payload == MSG_LEADER
                  || in[i]->value.payload == MSG_HEART) {
                  // Compare the term id, if they are equal, compare bank_index.
                  if (in[i]->value.term > self->term
                      || (in[i]->value.term == self->term && i > self->bank_index)) {
                      // Another node has declared itself to be the leader.
                      self->leader = i;
                      // Send back an ack.
                      lf_set(out[i], create_msg(MSG_ACK));
                      lf_print("(%lld, term=%d, leader=%d, Candidate) Acknowledge %d as leader", lf_time_logical_elapsed(), self->term, self->leader, i);
                      // Update its term to the leader's term.
                      self->term = in[i]->value.term;
                      // Renew the pending timeout action's expiry time.
                      lf_schedule(election_timeout_reached, self->election_timeout);
                      // Become a follower.
                      lf_set_mode(Follower);
                  }
              }
              else if (in[i]->value.payload == MSG_ELECTION) {
                  // Compare the term id, if they are equal, compare bank_index.
                  if (in[i]->value.term > self->term
                      || (in[i]->value.term == self->term && i > self->bank_index)) {
                      // Send back a vote.
                      lf_set(out[i], create_msg(MSG_VOTE));
                      lf_print("(%lld, term=%d, leader=%d, Candidate) Voting %d as leader", lf_time_logical_elapsed(), self->term, self->leader, i);
                      // Renew the pending timeout action's expiry time.
                      lf_schedule(election_timeout_reached, self->election_timeout);
                      // Become a follower.
                      lf_set_mode(Follower);
                  }
              }
          }
      }
    =}

    // If timeout is reached and no leader has been declared, then
    // we do not have a winner. Restart the election.
    reaction(election_timeout_reached) -> start_election {=
      lf_print("(%lld, term=%d, leader=%d, Candidate) No winner! Restart election.", lf_time_logical_elapsed(), self->term, self->leader);
      lf_schedule(start_election, 0);
    =}
  }
}

federated reactor(num_nodes: size_t = 5) {
  nodes = new[num_nodes] Node(num_nodes=num_nodes)
  nodes.out ~> interleaved(nodes.in)
}
