/**
 * The RandomDelay reactor simulates a physical connection with a random delay.
 * The timestamp at the receiving end is larger than the sender's timestamp by a random amount given
 * by an exponential random variable with 
 */
target C {
  keepalive: true
}

import WebSocketServerString from "../lib/WebSocketServerString.lf"
import Random from "../lib/Random.lf"

preamble {=
  #include <math.h>
  typedef struct complex_t {
    double real;
    double imaginary;
  } complex_t;
  typedef struct timestamped_complex_t {
    complex_t phasor;
    instant_t timestamp;
  } timestamped_complex_t;
=}

main reactor(n:int = 50) {
  s = new[n] PhaseMeasurementUnit(drift = 0.1, period = 100ms)
  t = new[n] RandomDelay(average = 1s)
  o = new Observer(n = n)
  s.phasor -> t.in
  t.out -> o.phasors
}

reactor RandomDelay(average: time = 1 sec, bank_index: int = 0) extends Random {
  input in: timestamped_complex_t
  output out: timestamped_complex_t
  logical action a: timestamped_complex_t

  reaction(startup) {=
    // Make sure each instance has a different seed.
    self->seed = (unsigned int) self->bank_index;
  =}

  reaction(a) -> out {=
    lf_set(out, a->value);
  =}

  reaction(in) -> a {=
    double lambda = SEC(1) / ((double)self->average);
    double exp = exponential(lambda);
    interval_t delay = (interval_t)llround(exp * (double)SEC(1));
    lf_schedule_copy(a, delay, &in->value, 1);
  =}
}

reactor PhaseMeasurementUnit(
    period:time = 100ms,
    bank_index:int = 0,         // identifier
    initial_phase:double = 0.0,
    drift:double = 0.0          // radians per second
) {
  output phasor:timestamped_complex_t
  timer t(0, period)
  state phase:double = initial_phase
  reaction(startup) {=
    // Give each instance a unique starting phase.
    self->phase = 0.1 * self->bank_index;
  =}
  reaction(t) -> phasor {=
    complex_t reading;
    reading.real = cos(self->phase);
    reading.imaginary = sin(self->phase);
    timestamped_complex_t tc;
    tc.phasor = reading;
    tc.timestamp = lf_time_logical();
    lf_set(phasor, tc);
    self->phase += (self->drift * self->period) / SEC(1);
  =}
}

reactor Observer(
  n:int = 2  // Number of inputs
) {
  input[n] phasors:timestamped_complex_t
  state connected:bool = false

  w = new WebSocketServerString(initial_file = {= LF_SOURCE_DIRECTORY LF_FILE_SEPARATOR "Synchrophasors.html" =})

  reaction(phasors) -> w.in_dynamic {=
    char* json = (char*)malloc(sizeof(char) * (2 + (7 * self->n)));
    char* p = json; // pointer to next position to write.
    *p++ = '[';
    for (int n = 0; n < self->n; n++) {
      if (n != 0) {
        *p++ = ',';
        *p++ = ' ';
      }
      long int height = lround(phasors[n]->value.phasor.real * 100);
      int len = snprintf(p, 5, "%3ld", height);
      if (len > 0) p += len; // Excluding trailing null terminator.
    }
    *p++ = ']';
    *p = '\0';
    if (self->connected) {
      lf_set(w.in_dynamic, json);
    }
    // lf_print("%s", json);
  =}
  reaction(w.connected) {=
    self->connected = w.connected->value;
  =}
}
